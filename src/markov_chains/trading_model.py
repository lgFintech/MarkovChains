"""
Trading-specific Markov chain model for financial market analysis.
"""

import numpy as np
from enum import Enum
from typing import List, Optional, Dict, Tuple
from dataclasses import dataclass

from .markov_chain import MarkovChain


class MarketState(Enum):
    """Possible market states for trading analysis."""
    BULL = "bull"  # Strong upward trend
    BEAR = "bear"  # Strong downward trend
    SIDEWAYS = "sideways"  # No clear trend


@dataclass
class TradingSignal:
    """A trading signal generated by the model."""
    action: str  # "buy", "sell", or "hold"
    confidence: float  # Probability of the predicted state
    current_state: MarketState
    predicted_state: MarketState
    state_probabilities: Dict[str, float]


class TradingMarkovModel:
    """
    A Markov chain model for analyzing and predicting market states.
    
    This model classifies market conditions into discrete states (bull, bear,
    sideways) and uses historical transitions to predict future market behavior
    and generate trading signals.
    
    Attributes:
        markov_chain: The underlying Markov chain
        bull_threshold: Return threshold for bull classification
        bear_threshold: Return threshold for bear classification
    """
    
    def __init__(
        self,
        bull_threshold: float = 0.02,
        bear_threshold: float = -0.02
    ):
        """
        Initialize the trading model.
        
        Args:
            bull_threshold: Minimum return to classify as bull market
            bear_threshold: Maximum return to classify as bear market
        """
        self.bull_threshold = bull_threshold
        self.bear_threshold = bear_threshold
        
        states = [state.value for state in MarketState]
        self.markov_chain = MarkovChain(states)
        self._fitted = False
    
    def classify_return(self, return_value: float) -> MarketState:
        """
        Classify a return value into a market state.
        
        Args:
            return_value: The price return (e.g., 0.05 for 5%)
        
        Returns:
            The corresponding market state
        """
        if return_value >= self.bull_threshold:
            return MarketState.BULL
        elif return_value <= self.bear_threshold:
            return MarketState.BEAR
        else:
            return MarketState.SIDEWAYS
    
    def fit(self, prices: List[float], period: int = 1) -> "TradingMarkovModel":
        """
        Fit the model on historical price data.
        
        Args:
            prices: List of historical prices (e.g., daily closing prices)
            period: Number of periods for return calculation (default: 1)
        
        Returns:
            self (for method chaining)
        
        Raises:
            ValueError: If not enough data points
        """
        if len(prices) < period + 1:
            raise ValueError(
                f"Need at least {period + 1} prices, got {len(prices)}"
            )
        
        prices = np.asarray(prices, dtype=np.float64)
        
        # Calculate returns
        returns = (prices[period:] - prices[:-period]) / prices[:-period]
        
        # Classify returns into states
        states = [self.classify_return(r).value for r in returns]
        
        # Fit the Markov chain
        self.markov_chain.fit(states)
        self._fitted = True
        
        return self
    
    def fit_from_returns(self, returns: List[float]) -> "TradingMarkovModel":
        """
        Fit the model directly from return data.
        
        Args:
            returns: List of price returns
        
        Returns:
            self (for method chaining)
        """
        if len(returns) < 2:
            raise ValueError("Need at least 2 returns to fit the model")
        
        # Classify returns into states
        states = [self.classify_return(r).value for r in returns]
        
        # Fit the Markov chain
        self.markov_chain.fit(states)
        self._fitted = True
        
        return self
    
    def predict(self, current_return: float) -> TradingSignal:
        """
        Generate a trading signal based on the current market return.
        
        Args:
            current_return: The current period's return
        
        Returns:
            A TradingSignal with action recommendation
        """
        if not self._fitted:
            raise ValueError("Model not fitted. Call fit() first.")
        
        current_state = self.classify_return(current_return)
        
        # Get predicted next state
        predicted_state_str, confidence = self.markov_chain.predict_next(
            current_state.value
        )
        predicted_state = MarketState(predicted_state_str)
        
        # Get full probability distribution
        idx = self.markov_chain._state_to_index[current_state.value]
        probs = self.markov_chain.transition_matrix[idx]
        state_probabilities = {
            state.value: float(probs[i])
            for i, state in enumerate(MarketState)
        }
        
        # Determine action
        action = self._determine_action(current_state, predicted_state, confidence)
        
        return TradingSignal(
            action=action,
            confidence=confidence,
            current_state=current_state,
            predicted_state=predicted_state,
            state_probabilities=state_probabilities
        )
    
    def _determine_action(
        self,
        current_state: MarketState,
        predicted_state: MarketState,
        confidence: float
    ) -> str:
        """
        Determine trading action based on current and predicted states.
        
        Args:
            current_state: Current market state
            predicted_state: Predicted next state
            confidence: Confidence in prediction
        
        Returns:
            Trading action: "buy", "sell", or "hold"
        """
        # Simple strategy: follow the predicted state
        if predicted_state == MarketState.BULL:
            return "buy"
        elif predicted_state == MarketState.BEAR:
            return "sell"
        else:
            return "hold"
    
    def get_regime_probabilities(self) -> Dict[str, float]:
        """
        Get the long-term probabilities of each market regime.
        
        Returns:
            Dictionary mapping market states to their steady-state probabilities
        """
        if not self._fitted:
            raise ValueError("Model not fitted. Call fit() first.")
        
        return self.markov_chain.steady_state_distribution()
    
    def get_expected_regime_duration(self, state: MarketState) -> float:
        """
        Get the expected duration of a market regime.
        
        This is 1 / (1 - P(stay in same state)), representing the expected
        number of periods the market stays in a given state.
        
        Args:
            state: The market state
        
        Returns:
            Expected number of periods in the state
        """
        if not self._fitted:
            raise ValueError("Model not fitted. Call fit() first.")
        
        stay_prob = self.markov_chain.get_transition_probability(
            state.value, state.value
        )
        
        if stay_prob >= 1.0:
            return float('inf')
        
        return 1.0 / (1.0 - stay_prob)
    
    def backtest(
        self,
        prices: List[float],
        initial_capital: float = 10000.0,
        transaction_cost: float = 0.001
    ) -> Dict[str, float]:
        """
        Backtest the trading strategy on historical data.
        
        Args:
            prices: Historical price data
            initial_capital: Starting capital
            transaction_cost: Transaction cost as fraction of trade value
        
        Returns:
            Dictionary with backtest results
        """
        if not self._fitted:
            raise ValueError("Model not fitted. Call fit() first.")
        
        if len(prices) < 2:
            raise ValueError("Need at least 2 prices for backtest")
        
        prices = np.asarray(prices, dtype=np.float64)
        returns = (prices[1:] - prices[:-1]) / prices[:-1]
        
        capital = initial_capital
        position = 0  # 1 for long, 0 for flat, -1 for short (not implemented)
        trades = 0
        wins = 0
        
        for i, current_return in enumerate(returns[:-1]):
            signal = self.predict(current_return)
            next_return = returns[i + 1]
            
            prev_position = position
            
            if signal.action == "buy" and position == 0:
                position = 1
                capital *= (1 - transaction_cost)
                trades += 1
            elif signal.action == "sell" and position == 1:
                position = 0
                capital *= (1 - transaction_cost)
                trades += 1
            
            # Apply return if in position
            if position == 1:
                capital *= (1 + next_return)
                if next_return > 0:
                    wins += 1
        
        # Close any open position at the end
        if position == 1:
            capital *= (1 - transaction_cost)
        
        total_return = (capital - initial_capital) / initial_capital
        
        # Calculate buy-and-hold return for comparison
        buy_hold_return = (prices[-1] - prices[0]) / prices[0]
        
        return {
            "final_capital": capital,
            "total_return": total_return,
            "buy_hold_return": buy_hold_return,
            "excess_return": total_return - buy_hold_return,
            "num_trades": trades,
            "win_rate": wins / max(trades, 1)
        }
    
    def get_transition_matrix(self) -> np.ndarray:
        """
        Get the transition probability matrix.
        
        Returns:
            The transition matrix as a numpy array
        """
        if not self._fitted:
            raise ValueError("Model not fitted. Call fit() first.")
        
        return self.markov_chain.transition_matrix.copy()
    
    def simulate_market(
        self,
        initial_state: MarketState,
        n_periods: int,
        rng: Optional[np.random.Generator] = None
    ) -> List[MarketState]:
        """
        Simulate future market states.
        
        Args:
            initial_state: Starting market state
            n_periods: Number of periods to simulate
            rng: Optional random number generator
        
        Returns:
            List of simulated market states
        """
        if not self._fitted:
            raise ValueError("Model not fitted. Call fit() first.")
        
        state_sequence = self.markov_chain.simulate(
            initial_state.value, n_periods, rng
        )
        
        return [MarketState(s) for s in state_sequence]
    
    def __repr__(self) -> str:
        """String representation of the model."""
        status = "fitted" if self._fitted else "not fitted"
        return (
            f"TradingMarkovModel("
            f"bull_threshold={self.bull_threshold}, "
            f"bear_threshold={self.bear_threshold}, "
            f"status={status})"
        )
